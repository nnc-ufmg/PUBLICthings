#include <SPI.h>
#include <SD.h>

#define numero_entradas 4
#define TamanhoMaxDaTabela 100
#define DEBOUNCE_TIME 70
#define BlinkTimeInterval 1000
#define numero_botoesOUT 3

//TABELAS
int botoesOUT[numero_botoesOUT] = {2, 3};  // Pinos de saída para LED
int botoes[ numero_entradas] = {18, 19, 20, 21};  // Pinos dos botões
String TABELAEVENTOS_entradas[numero_entradas][TamanhoMaxDaTabela];

//pino CS do cartão
const int chipSelect = 38; 

//variáveis
int tempoLED=0;
int contagem = 0;
long int countTabela = 0;
unsigned long TABELAEVENTOS_tempo[TamanhoMaxDaTabela];
unsigned long tempoUltimaLeituraTabela = 0;
unsigned long tempoUltimaLeitura[numero_entradas] = {0, 0}; 
unsigned long tempoAtual = 0;
unsigned long tempoBLINK = 0;
bool bBlinkState = false;
bool estadoAnterior[ numero_entradas] = {LOW, LOW, LOW, LOW};
bool estadoAnteriorBotao13 = LOW;
bool eventoJaRegistrado = false;
bool estadoAtual;
File dataFile;


void setup() {
  Serial.begin(9600);

  // Inicializa a tabela com "-"
  for (int i = 0; i <  numero_entradas; i++) {
    for (int j = 0; j < TamanhoMaxDaTabela; j++) {
      TABELAEVENTOS_entradas[i][j] = "-";
    }
  }

  // Inicializa o cartão SD
  if (!SD.begin(chipSelect)) {
    Serial.println("Falha ao conectar com o cartao SD");
    return;
  }
  Serial.println("Cartao SD conectado");

  // Configura os pinos de saída para LED
  for (int i = 0; i < numero_botoesOUT; i++) {
    pinMode(botoesOUT[i], OUTPUT);
  }

  // Configura os pinos dos botões como entradas
  for (int i = 0; i <  numero_entradas; i++) {
    pinMode(botoes[i], INPUT);
  }

  pinMode(46, INPUT);  // Botão para impressão 
  
  // Abre o arquivo para gravação (modo append, para não sobrescrever os dados)
  dataFile = SD.open("datalog.csv", FILE_WRITE);
  if (dataFile) {
    Serial.println("Arquivo aberto para gravação.");
  } else {
    Serial.println("Falha ao abrir o arquivo.");
  }
}

void gravarTabelaNoCartao() {
  if (dataFile) {
    Serial.println("Gravando dados no cartão SD...");

    for (int i = 0; i < countTabela; i++) {
      dataFile.print(TABELAEVENTOS_tempo[i]);  // Tempo do evento
      dataFile.print(",");   
      for(int j = 0; j < numero_entradas; j++) { // Separador CSV
        dataFile.print(TABELAEVENTOS_entradas[j][i]);
        if (j < numero_entradas - 1) {
          dataFile.print(","); // Adiciona vírgula apenas entre os valores
        }
      }
      dataFile.println(); 
    }
    
    dataFile.flush();  // Garante que os dados sejam gravados imediatamente
    Serial.println("Dados gravados e tabela limpa.");

    // Limpa a tabela
    countTabela = 0;
    for (int i = 0; i <  numero_entradas; i++) {
    for (int j = 0; j < TamanhoMaxDaTabela; j++) {
      TABELAEVENTOS_entradas[i][j] = "-";
    }

  }
  } else {
    Serial.println("Erro ao gravar no cartão SD.");
  }
}


void imprimirMatriz() {
  Serial.println("Imprimindo tabela:");
  
  for (int i = 0; i < countTabela; i++) {
    Serial.print(TABELAEVENTOS_tempo[i]);  // Tempo do evento
    Serial.print("\t");   
    for (int j = 0; j <  numero_entradas; j++) {  // Separador CSV
      Serial.print(TABELAEVENTOS_entradas[j][i]); // Número do botão pressionado
      Serial.print("\t");  // Inserir tabulação após cada valor
    }
    Serial.println();  // Adicionar uma nova linha após todos os botões
  }
}


void ler_entradas() {
   // Escreve os dados no arquivo se necessário
   if (contagem > 7) {
      imprimirMatriz();
      contagem = 0;
     // gravarTabelaNoCartao(); 
   }

   eventoJaRegistrado = false;

    for (int i = 0; i <  numero_entradas; i++) {
        estadoAtual = digitalRead(botoes[i]);

        if (estadoAtual == HIGH && estadoAnterior[i] == LOW) {
            if ((tempoAtual - tempoUltimaLeitura[i]) > DEBOUNCE_TIME) {
                digitalWrite(3, HIGH);
                tempoLED = 10000;

                Serial.print("A entrada digital ");
                Serial.print(i);
                Serial.print(" foi pressionada: ");
                Serial.println(tempoAtual);

                if (TABELAEVENTOS_tempo[countTabela - 1] == tempoAtual) {
                    eventoJaRegistrado = true;
                   // TABELAEVENTOS_entradas[i][countTabela - 1] = estadoAtual;
                   TABELAEVENTOS_entradas[i][countTabela - 1] = i;

                }

                if (!eventoJaRegistrado && countTabela < TamanhoMaxDaTabela) {
                    tempoUltimaLeitura[i] = tempoAtual;
                    TABELAEVENTOS_tempo[countTabela] = tempoAtual;
                     TABELAEVENTOS_entradas[i][countTabela - 1] = i;

                   // TABELAEVENTOS_entradas[i][countTabela] = estadoAtual;
                    countTabela++;
                    contagem++;
  
                }
            }
        } else {
            if (tempoLED > 0) {
                digitalWrite(2, HIGH);
                tempoLED--;
            } else {
                digitalWrite(2, LOW);
            }
        }
        estadoAnterior[i] = estadoAtual;
    }
}


void verificarConteudoDoArquivo() {
  Serial.println("Verificando conteúdo do arquivo");
  
  if (dataFile) {  // Verifica se o arquivo foi aberto corretamente
    // Posiciona o ponteiro de leitura no início do arquivo
    dataFile.seek(0);
    
    Serial.println("Conteúdo do arquivo:");
    while (dataFile.available()) {
      Serial.write(dataFile.read());  // Lê e imprime o conteúdo
    }
   
  } else {
    Serial.println("Falha ao abrir o arquivo para leitura.");
  }
}


void loop() {
  tempoAtual = millis();
  ler_entradas();

  // Controle do LED com intervalo de blink
  if ((tempoBLINK + BlinkTimeInterval) < millis()) {
    tempoBLINK = millis();
    digitalWrite(botoesOUT[1], bBlinkState);  // Controla o LED no pino 53
    bBlinkState = !bBlinkState;
  }

  // Imprime o conteúdo do arquivo quando o botão 46 for pressionado
  if ((tempoAtual - tempoUltimaLeituraTabela) > DEBOUNCE_TIME) {
    estadoAtual = digitalRead(46);
    if (estadoAtual == HIGH && estadoAnteriorBotao13 == LOW) {
      verificarConteudoDoArquivo();  // Chama a função para verificar o conteúdo
      //imprimirMatriz();
      tempoUltimaLeituraTabela = tempoAtual;
    }
    estadoAnteriorBotao13 = estadoAtual;
  }
}
