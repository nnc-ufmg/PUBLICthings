 #include <SPI.h>
#include <SD.h>

#define NUMERO_PINOS_DIGITAIS 4 
#define NUMERO_PINOS_ANALOGICOS 2
#define TamanhoMaxDaTabela 100
#define DEBOUNCE_TIME 70
#define BlinkTimeInterval 1000
#define numero_botoesOUT 2

//LED verde pisca quando entra no loop
//LED vermelho pisca quando recebe um sinal 
//pino 2 do UNO envia para o pino 20 do MEGA
//pino 3 do UNO envia para o pino 18 do MEGA
//pino 4 do UNO envia para o pino 21 do MEGA (PULSO DO POTENCIOMETRO)
//pino 5 do UNO envia para o pino 19 do MEGA

const int entradaAnalogica3 = A2; // Pino do potenciômetro
const int chipSelect = 38; //pino CS do cartão
const int numeroTotalDePins = NUMERO_PINOS_DIGITAIS + NUMERO_PINOS_ANALOGICOS;

//TABELAS
int pinosDigitais[NUMERO_PINOS_DIGITAIS ] = {18, 19, 20, 21};  // Pinos dos botões
int pinosAnalogicos[NUMERO_PINOS_ANALOGICOS] = {A2, A13};  // Pinos analógicos
int botoesOUT[numero_botoesOUT] = {2, 3};  // Pinos de saída para LED
unsigned long tempoUltimaLeitura[NUMERO_PINOS_DIGITAIS ] = {0}; 
String TABELAEVENTOS_botoes[numeroTotalDePins][TamanhoMaxDaTabela];
unsigned long TABELAEVENTOS_tempo[TamanhoMaxDaTabela];

//VARIÁVEIS 
const unsigned long intervalo3 = 7000; // 7 segundos
unsigned long ultimaLeitura3 = 0;
unsigned long tempoAtual = 0;
unsigned long tempoBLINK = 1000;
unsigned long tempoUltimaLeituraTabela = 0;
long int countTabela = 0;
int tempoLED=0;
int contagem = 0;
bool bBlinkState = false;
bool estadoAnterior[NUMERO_PINOS_DIGITAIS ] = {LOW, LOW, LOW, LOW};
bool estadoAnteriorBotao13 = LOW;
bool estadoAtual;
bool eventoJaRegistrado = false;
File dataFile;



// Estrutura que associa um pino, o tipo do sensor e a função de leitura
struct Sensor {
  int pin;
  bool associadoAnalog;
  int pinoAssociado;
  int colunaTabela;
  unsigned long ultimoHorario;
  float lastValue;
  void (*readFunc)(); // Função de leitura do sensor, ponteiro que aponta para uma função (*readFunc) e que não recebe parâmetro ()
};

//FUNÇÕES
void lerEntradasAnalogicas(Sensor &sensorAssociado);
void lerEntradasDigitais();

//array de sensores para automatizar as leituras
Sensor sensores[] = {
  {18, false, 1, 0, 0, 0, lerEntradasDigitais},           // Botão 1
  {19, true, A13, 5, 0, 0, lerEntradasDigitais},           // Botão 2 onda
  {20, false, 1, 0, 0, 0, lerEntradasDigitais},           // Botão 3
  {21, true, A2, 4, 0, 0, lerEntradasDigitais},           // Botão 4 associado ao potenciomêtro
};

void setup() {
  Serial.begin(9600);

  // Inicializa a tabela com "-"
  for (int i = 0; i < numeroTotalDePins; i++) {
    for (int j = 0; j < TamanhoMaxDaTabela; j++) {
      TABELAEVENTOS_botoes[i][j] = "-";
    }
  }

  // Inicializa o cartão SD
  if (!SD.begin(chipSelect)) {
    Serial.println("Falha ao conectar com o cartao SD");
    return;
  }
  Serial.println("Cartao SD conectado");

  // Configura os pinos de saída para LED
  for (int i = 0; i < numero_botoesOUT; i++) {
    pinMode(botoesOUT[i], OUTPUT);
  }

  // Configura os pinos dos botões como entradas
  for (int i = 0; i < NUMERO_PINOS_DIGITAIS ; i++) {
    pinMode( pinosDigitais[i], INPUT);
  }

  for (int i = 0; i < NUMERO_PINOS_ANALOGICOS ; i++) {
    pinMode( pinosAnalogicos[i], INPUT);
  }

  pinMode(46, INPUT);  // Botão para impressão 
  
  // Abre o arquivo para gravação (modo append, para não sobrescrever os dados)
  dataFile = SD.open("datalog.csv", FILE_WRITE);
  if (dataFile) {
    Serial.println("Arquivo aberto para gravação.");
  } else {
    Serial.println("Falha ao abrir o arquivo.");
  }

}


void gravarTabelaNoCartao() {
  if (dataFile) {
    Serial.println("Gravando dados no cartão SD...");

    for (int i = 0; i < countTabela; i++) {
      dataFile.print(TABELAEVENTOS_tempo[i]);  // Tempo do evento
      dataFile.print(",");   
      for(int j = 0; j < numeroTotalDePins; j++) { // Separador CSV
        dataFile.print(TABELAEVENTOS_botoes[j][i]);
        if (j < numeroTotalDePins - 1) {
          dataFile.print(","); // Adiciona vírgula apenas entre os valores
        }
      }
      dataFile.println(); 
    }
    
    dataFile.flush();  // Garante que os dados sejam gravados imediatamente
    Serial.println("Dados gravados e tabela limpa.");

    // Limpa a tabela
    countTabela = 0;
  } else {
    Serial.println("Erro ao gravar no cartão SD.");
  }
}

void imprimirMatriz() {
  Serial.println("Imprimindo tabela:");
  
  for (int i = 0; i < countTabela; i++) {
    Serial.print(TABELAEVENTOS_tempo[i]);  // Tempo do evento
    Serial.print("\t");   
    for (int j = 0; j < numeroTotalDePins; j++) {  // Separador CSV
      Serial.print(TABELAEVENTOS_botoes[j][i]); // Número do botão pressionado
      Serial.print("\t");  // Inserir tabulação após cada valor
    }
    Serial.println();  // Adicionar uma nova linha após todos os botões
  }
}

void lerEntradasDigitais() {
   // Escreve os dados no arquivo se necessário
   if (contagem > 7) {
      //imprimirMatriz();
      contagem = 0;
      gravarTabelaNoCartao(); 
   }
   eventoJaRegistrado = false;
    for (int i = 0; i < NUMERO_PINOS_DIGITAIS; i++) {
        estadoAtual = digitalRead(pinosDigitais[i]);

        if (estadoAtual == HIGH && estadoAnterior[i] == LOW) {
            if ((tempoAtual - tempoUltimaLeitura[i]) > DEBOUNCE_TIME) {
                sensores[i].lastValue = 1;  // Mantém o lastValue em 1
                sensores[i].ultimoHorario = tempoAtual;
                digitalWrite(3, HIGH);
                tempoLED = 10000;

                Serial.print("O botão ");
                Serial.print(i);
                Serial.print(" foi pressionado: ");
                Serial.println(tempoAtual);

                if (TABELAEVENTOS_tempo[countTabela - 1] == tempoAtual) {
                    eventoJaRegistrado = true;
                    TABELAEVENTOS_botoes[i][countTabela - 1] = estadoAtual;
                }

                if (!eventoJaRegistrado && countTabela < TamanhoMaxDaTabela) {
                    tempoUltimaLeitura[i] = tempoAtual;
                    TABELAEVENTOS_tempo[countTabela] = tempoAtual;
                    TABELAEVENTOS_botoes[i][countTabela] = 1;
                    countTabela++;
                    contagem++;
                if(sensores[i].associadoAnalog == true){
                  lerEntradasAnalogicas(sensores[i]);
                }
                }
            }
        } else {
            if (tempoLED > 0) {
                digitalWrite(2, HIGH);
                tempoLED--;
            } else {
                digitalWrite(2, LOW);
            }
        }
        estadoAnterior[i] = estadoAtual;
    }
}

void lerEntradasAnalogicas(Sensor &sensorAssociado) {

        Serial.println("Lendo potenciômetro...");
        
        int valor = analogRead(sensorAssociado.pinoAssociado);        
        float tensao = (valor * 5000.0) / 1023.0;                 
        // Verifica apenas o último evento
        if (TABELAEVENTOS_tempo[countTabela - 1] == tempoAtual) {
         eventoJaRegistrado = true;
         // Atualiza a tabela para indicar que o valor do potenciômetro foi lido nesse tempo
         TABELAEVENTOS_botoes[sensorAssociado.colunaTabela][countTabela - 1] =tensao;
        }

        // Se não foi registrado, adicionamos um novo evento
        if (!eventoJaRegistrado && countTabela < TamanhoMaxDaTabela) {
         TABELAEVENTOS_tempo[countTabela] = tempoAtual;
         TABELAEVENTOS_botoes[sensorAssociado.colunaTabela][countTabela] = tensao;  // Armazena o valor do potenciômetro
         countTabela++;
         contagem++;  // Incrementa a contagem
      }


        Serial.print(" Entrada analógica ");
        Serial.print(sensorAssociado.pinoAssociado);
        Serial.print(" lida no tempo: ");
        Serial.print(TABELAEVENTOS_tempo[countTabela - 1]);
        Serial.print(": ");
        Serial.print(tensao);
        Serial.println(" mV");

    
}



void verificarConteudoDoArquivo() {
  Serial.println("Verificando conteúdo do arquivo");
  
  if (dataFile) {  // Verifica se o arquivo foi aberto corretamente
    // Posiciona o ponteiro de leitura no início do arquivo
    dataFile.seek(0);
    
    Serial.println("Conteúdo do arquivo:");
    while (dataFile.available()) {
      Serial.write(dataFile.read());  // Lê e imprime o conteúdo
    }
   
  } else {
    Serial.println("Falha ao abrir o arquivo para leitura.");
  }
}


void loop() {
  tempoAtual = millis();

  for (int i = 0; i < sizeof(sensores)/sizeof(sensores[0]); i++) {
   sensores[i].readFunc();
  }

  
 // Verifica se passou 1 segundo desde a última troca de estado do LED
  if ((tempoAtual - tempoBLINK) >= BlinkTimeInterval) {
    tempoBLINK = tempoAtual;  // Atualiza o tempo da última troca
    bBlinkState = !bBlinkState;  // Alterna o estado do LED
    digitalWrite(2, bBlinkState);  // Liga/desliga o LED
  }

  // Imprime o conteúdo do arquivo quando o botão 46 for pressionado
  if ((tempoAtual - tempoUltimaLeituraTabela) > DEBOUNCE_TIME) {
    estadoAtual = digitalRead(46);
    if (estadoAtual == HIGH && estadoAnteriorBotao13 == LOW) {
      verificarConteudoDoArquivo();  // Chama a função para verificar o conteúdo
      //imprimirMatriz();
      tempoUltimaLeituraTabela = tempoAtual;
    }
    estadoAnteriorBotao13 = estadoAtual;
  }
} 
